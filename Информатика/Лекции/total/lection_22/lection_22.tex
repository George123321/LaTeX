\chapter{Деревья. Двоичное дерево поиска.}
\section{Двоичное дерево. Класс  дерево.}
\textsf{k-ичное дерево} --- дерево, в котором количество дочерних вершин у каждой вершины не больше k штук. При этом троичное дерево является одновременно и четверичным --- просто четвертого ребра еще нет. Последовательность дочерних вершин может быть неупорядоченной. Нам же интересен случай, когда k-ичное дерево является упорядоченным. 

Рассмотрим двоичное дерево, упорядоченное, в общем случае не сбалансированное (в отличии от кучи). Двоичное дерево можно нарисовать так, что мы будем называть дочерние вершины "левая"\ или "правая" (по аналогии с кучей). 

\textsf{Поддерево} (правое/левое) --- подграф дерева, корень которого является дочерней вершиной (правой/левой). 

В прошлом семестре вводился такой способ хранения данных как односвязный список. Оказывается, можно реализовать такое звено, которое подходит для двоичного дерева поиска. Сделаем 2 указателя: на левое поддерево и правое поддерево, также указатель наверх (т.е. на родителя). Из таких звеньев можно собирать дерево.

Удобно считать пустой граф пустым деревом (хотя по определению дерева это неверно).

\begin{infa}{Класс Дерево}
\ \num \classi Node:
\ \num \tab \defi __init__(self, key, value): \com{Создаем звено ключ, значение}
\ \num \tab \tab self.key = key 
\ \num \tab \tab self.value = value 
\ \num \tab \tab self.parent = \Nonei
\ \num \tab \tab self.left = \Nonei
\ \num \tab \tab self.right = \Nonei
\ \num
\ \num \classi Tree:
\num \tab \defi __init__(self):
\num \tab \tab self.root = \Nonei
\num \tab \defi print(self, node):
\num \tab \tab \ifi node \isi \Nonei: \com{Благодаря этому нам не важно, пустое наше поддерево\\\phantom{ 5\ \ \ \ } или нет - крайний случай проверен}
\num \tab \tab \tab \returni
\num \tab \tab self.print(node.left)
\num \tab \tab \printi((node.key, node.value)) \com{Это не совсем обратный ход рекурсии}
\num \tab \tab self.print(node.right)
\end{infa}

\section{Двоичное дерево поиска}
\textsf{Двоичное дерево поиска} --- это корневое двоичное упорядоченное дерево, построенное по следующему правилу для любого звена node: все ключи левого поддерева $key_i<key_{node}$, все ключи правого поддерева $key_j>key_{node}$.

Возьмем такие числа:
$$
6\ 3\ 5\ 4\ 2\ 9\ 7\ 8\ 1\ 11\ 10\ 12\ 0
$$
и изобразим для них двоичное дерево поиска (рис. \ref{fig_dvderevo}).

\begin{figure}
	\centering
	%\vspace{-2.5cm}
	\def\svgwidth{17cm} % если надо изменить размер
	\input{lection_22/graph_derevo.pdf_tex}
	\caption{Двоичное дерево поиска}
	\label{fig_dvderevo}
	%\vspace{-9cm}
\end{figure}

Алгоритм построения: сначала дерево пустое и ни одного звена нет. Берем числа поочереди. 3 меньше 6, поэтому 6 становится главной. 3 становится левым поддеревом шестерки, т.к. $3<6$ (добавляем числа меньшие корня в левое поддерево, а числа большие корня в правое поддерево). Далее число 5 меньше 5, но больше 3. Поэтому 5 находится в левом поддереве 6, но в правом поддереве тройки. Дальнейшее построение аналогично. Красота такого метода в том, что если <<спроектировать>> числа на прямую, получается числовая ось, на которой числа расставлены в порядке возрастания.

Двоичное дерево поиска работает как бинарный поиск. Количество операций сравнения равно высоте дерева $O(\log_2N)$ (если дерево сбалансировано). Чем оно лучше бинарного поиска в списке? Для добавления элемента требуется то же время ($O(\log_2N)$). Но в списке после того, как мы нашли, куда вставить элемент, требуется сделать циклический сдвиг.

Если у элемента нет дочерних вершин, а его надо удалить, то это сделать просто. Но вот если у него есть одна дочерняя вершина, мы присоединяем оставшееся дерево к верхнему родителю (можно привести аналогию с подчиненными: если начальника подчиненных уволили, то эти подчиненные становятся подчиненными начальника рангом выше).

В случае когда нужно присоеденить 2 дерева (т.е. если мы удалили вершину, у которого было 2 поддерева, например третью) переходим к левому поддереву удаляемой вершины и к самому правому из него добавляем правое поддерево той вершины, которую мы удалили. Минусы: при удалении корневого элемента длина дерева удваивается.

Но есть более оптимальный вариант: после удаления вершины (например тройки) возьмем самый правый элемент левого поддерева этой вершины (т.е. тройки) и поставим его вместо элемента, которого мы удалили (т.е. вместо стройки), что предотвратит от удваивания длины всего дерева (т.е. если бы у двойки было бы правое поддерево, мы бы нашли самый большой элемент в этом поддереве и поставили бы его на место тройки).

Почему не воспользоваться хеш--таблицей? Хеш--таблица не упорядочена, в отличии от двоичного дерева поиска.