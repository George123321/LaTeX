\chapter{Кодирование}
\section{Равномерное и неравномерное кодирование}
Есть два глобальных подхода в кодировании текста: равномерное кодирование и неравномерное кодирование.

Обозначим алфавит допустимых символов $\mathbb{A}$.

В неравномерном кодировании код символов разной длины (например, UNICODE UTF 8 --- одна из
самых популярных кодировок).

Рассмотрим четырехбуквенное кодирование. Закодируем буквы <<А>>, <<Б>>, <<В>>, <<Г>> таким образом:
\begin{center}
	$
\begin{array}{rl}
\text{А} &= 0\\
\text{Б} &= 1\\
\text{В} &= 10\\
\text{Г} &= 111\\
\end{array}
$
\end{center}
Тогда запись <<ГАГА>> можно закодировать так:
\begin{center}
ГАГА = 11101110 = БББГА,
\end{center}
т.е. декодирование неоднозначно, такое кодирование плохое.

\textbf{Условие Фано:} \textit{для того, чтобы сообщение, записанное с помощью неравномерного по длине кода, однозначно раскодировалось, достаточно, чтобы никакой код не был началом другого (более длинного) кода.} \textbf{Обратное условие Фано} (\textit{ни один код не является концом (суффиксом) другого}) также является достаточным условием однозначного декодирования неравномерного кода.

Тогда пусть
\begin{center}
$
\begin{array}{rl}
\centering
\text{А} &= 0\\
\text{Б} &= 110\\
\text{В} &= 10\\
\text{Г} &= 111\\
\end{array}
$
\end{center}

Возьмем (для удобства рядом записан столбец в зеркальном отражении):
\begin{center}
$
\begin{array}{rlcr}
\text{A} = &1&\vrule&1\\
\text{Б} = &10&\vrule&01\\
\text{В} = &100&\vrule&001\\
\text{Г} = &000&\vrule&000\\
\end{array}
$
\end{center}
Тогда
\begin{center}
БАГАВА = 10100011001 
\end{center}
--- 1100 нет, т.е в конце ВА. 1000 тоже нет, т.е. по середине ГА. 101 нет, в начале БА. Однозначность есть, хотя и декодировать очень сложно. 

Составим суффиксное дерево. Оно не нужно при декодировании, а при доработке дерева (дополнении алфавита) является полезным инструментом. Способ составления: отзеркаливаем код и строим дерево, в котором каждое ребро --- цифра в коде.

Кодировка в равномерном кодировании UTF-16. Можно закодировать $2^n$ различных символов (мощность алфавита).
%FIXME вставить рисунок префиксного дерева

\section{Поиск подстроки в строке}
\subsection{Наивный поиск подстроки в строке}
\begin{infa}{Примитивный поиск подстроки в строке}
\ \num s = "abbbbabbaaabbababaabb"
\ \num subs = "bbbaba"
\ \num \defi find(s, sub):
\ \num \tab \fori pos \ini \rangei(0, \leni(s)-\leni(sub)+1):
\ \num \tab \tab \fori i \ini \rangei(\leni(sub)):
\ \num \tab \tab \tab \ifi sub[i] != s[pos+i]:
\ \num \tab \tab \tab \tab \breaki
\ \num \tab \tab \elsei:
\ \num \tab \tab \tab \returni pos
\num \tab \returni -1
\end{infa}
Построчный комментарий кода:\\
4) Имеет смысл проходить по основной строке, пока входящая строка влезает в рассматриваемый участок.\\
5)--6) Пробегаемся по элементам входящей строки и смотрим, совпадают ли они с элементами основной.\\
7) Если нет, уже можно переходить к следующему элементу основной строки.\\
9) Если прошли по всем элементам строки вхождения, можно выдать ту позицию, начиная с которой есть вхождение.\\
10) Если вхождения нет, выдается ‘-1’.

Сложность алгоритма $O(N\cdot M)$. В итоге алгоритм получается неэффективным.
\subsection{Конечный автомат поиска <<abcd>>}
Смотрим на каждый символ только  по одному разу! Методика хранения автомата: орграф. Если конечный автомат уже построен, то время поиска $O(N)$, $N$ --- длина строки.

Конечный автомат поиска является частным случаем машины Тьюринга, Подход таков:
\begin{enumerate}
	\item Изначально система в фазе ноль.
	\item Сравниваем букву в основной строке с буквой во входящей строке. Если они совпали, то код продвигается на фазу вперед.
	\item Сравниваем следующие буквы. Если они совпали, переходим в фазу два и т.д.
	\item В случае несовпадения фаза становится нулевой.
\end{enumerate}

\begin{infa}{Конечный автомат для поиска подстроки <<abcd>>}
\ \num state = 0
\ \num \fori c in s:
\ \num \tab \ifi state == 0:
\ \num \tab \tab \ifi c == "a":
\ \num \tab \tab \tab state = 1
\ \num \tab \elifi state == 1:
\ \num \tab \tab \ifi c == 'b':
\ \num \tab \tab \tab state = 2
\ \num \tab \tab \elifi c == 'a':
\num \tab \tab \tab state = 1
\num \tab \tab \elsei:
\num \tab \tab \tab state = 0
\num \tab \elifi state == 2:
\num \tab \tab \ifi c == 'c':
\num \tab \tab \tab state = 3
\num \tab \tab \elifi c == 'a':
\num \tab \tab \tab state = 1
\num \tab \tab \elsei:
\num \tab \tab \tab state = 0
\num \tab \elifi state == 3:
\num \tab \tab \ifi c == 'a':
\num \tab \tab \tab state = 1
\num \tab \tab \elifi c == 'd':
\num \tab \tab \tab state = 4
\num \tab \tab \elsei:
\num \tab \tab \tab state = 0
\end{infa}
\section{Расстояние Левенштейна}
\subsection{Определение}
\textbf{Расстояние Левенштейна} (также редакционное расстояние или дистанция редактирования) \textbf{между двумя строками в теории информации и компьютерной лингвистике} --- \textit{это минимальное количество операций вставки одного символа, удаления одного символа и замены одного символа на другой, необходимых для превращения одной строки в другую.}

Есть 2 строки Мама и Мим. Мы можем превратить их друг в друга путем вставки символа, удаления символа. Минимальный путь в данном случае --- удаление последнего и замена, т.е. длина пути 2. Так и определяется расстояние Левенштейна.

a[:i], b[:j] --- срезы до i--го и j--го символа.
$F_{ij} = L(a[:i], b[:j])$ --- расстояние Левенштейна. Тогда\\
$$F_{ij}=
\begin{cases}
\text{Последниие буквы совпадают, то } F_{(i-1)(j-1)}\\
1+\min(F_{(i-1)(j-1)}, F_{(i-1)j}, F_{i(j-1)})
\end{cases}
$$
\subsection{Реализация алгоритма поиска расстояния Левенштейна}
\begin{infa}{Рекуррентная реализация поиска расстояния Левенштейна}
\num \defi lev(a, b):
\num \tab \ifi \noti a: 
\num \tab \tab \returni \leni(b)
\num \tab \ifi \noti b: 
\num \tab \tab \returni \leni(a)
\num \tab \returni \mini(lev(a[1:], b[1:])+(a[0] != b[0]), lev(a[1:], b)+1, lev(a, b[1:])+1)
\end{infa}
Данный алгоритм записывается компактно, но асимптотика этого алгоритма ужасна.

\begin{infa}{Реализация поиска расстояния Левенштейна}
\ \num \defi levenshtein(s1, s2):
\ \num \tab \ifi \leni(s1) < \leni(s2):
\ \num \tab \tab \returni levenshtein(s2, s1)
\ \num 
\ \num \tab \ifi \leni(s2) == 0:
\ \num \tab \tab \returni \leni(s1)
\ \num
\ \num \tab previous_row = \rangei(\leni(s2) + 1)
\ \num \tab \fori i, c1 \ini \enumeratei(s1):
\num \tab \tab current_row = [i + 1]
\num \tab \tab \fori j, c2 \ini \enumeratei(s2):
\num \tab \tab \tab insertions = previous_row[j + 1] + 1
\num \tab \tab \tab deletions = current_row[j] + 1     
\num \tab \tab \tab substitutions = previous_row[j] + (c1 != c2)
\num \tab \tab \tab current_row.append(\mini(insertions, deletions, substitutions))
\num \tab \tab previous_row = current_row
\num
\num \tab \returni previous_row[-1]
\end{infa}